'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/mockk-guidebook/docs/mockito-migrate/create-mock/','title':"Create a mock",'section':"Migrating from Mockito",'content':"Create a mock #  The syntax to create a mock is very similar in Mockito and MockK. However, the behaviour is slightly different.\n// Mockito val mockedFile = mock(File::class.java) mockedFile.read() // does nothing // MockK val mockedFile = mockk\u0026lt;File\u0026gt;() mockedFile.read() // throws because the method was not stubbed Mocked objects in MockK resemble Mockito\u0026rsquo;s STRICT_STUBS mode by default. If a method is not stubbed, then it will throw. This makes it easier to catch methods that are being called when you do not expect it, or when methods are being called with different arguments.\nMockito\u0026rsquo;s default lenient behaviour can be replicated with the relaxed setting. Relaxed mocks will have default stubs for all methods.\n// MockK val mockedFile = mockk\u0026lt;File\u0026gt;(relaxed = true) mockedFile.read() // will not throw If desired, you can choose to only relax methods that return Unit.\n// MockK val mockedFile = mockk\u0026lt;File\u0026gt;(relaxUnitFun = true) mockedFile.read() // returns Unit, will not throw mockedFile.exists() // throws as the method returns Boolean "});index.add({'id':1,'href':'/mockk-guidebook/docs/mockito-migrate/when/','title':"`when` and `do*`",'section':"Migrating from Mockito",'content':"when and do* #  Mockito provides two similar approaches for stubbing behaviour on a mock: the when method and the do* family of methods.\nMost stubs in Mockito are written with when at the beginning of the line, following the format \u0026ldquo;when the method is called then return something\u0026rdquo;. Stubs written with the when method look like this:\nval mockedFile = mock(File::class.java) `when`(mockedFile.read()).thenReturn(\u0026#34;hello world\u0026#34;) Sometimes this syntax cannot be used in Mockito, so an alternative approach is available. doReturn and the related doThrow, doAnswer, doNothing, and doCallRealMethod methods are used for void methods, spies, and other occasions where the when method cannot be used. Stubs written with the do* family of methods look like this:\nval mockedFile = mock(File::class.java) doReturn(\u0026#34;hello world\u0026#34;).`when`(mockedFile).read() In MockK, all stubs can be written with the every method. every starts a stubbing block and uses anonymous functions and infix functions to define the stub. The syntax looks like this:\nval mockedFile = mockk\u0026lt;File\u0026gt;() every { mockedFile.read() } returns \u0026#34;hello world\u0026#34; MockK provides alternatives for many types of answers that Mockito supports for stubbing.\nthenReturn/doReturn #  Returning a value is probably the most common stub to create. In Mockito, the syntax can look like one of two approaches:\nval mockedFile = mock(File::class.java) `when`(mockedFile.read()).thenReturn(\u0026#34;hello world\u0026#34;) doReturn(\u0026#34;hello world\u0026#34;).`when`(mockedFile).read() In MockK, an infix function is used instead.\nval mockedFile = mockk\u0026lt;File\u0026gt;() every { mockedFile.read() } returns \u0026#34;hello world\u0026#34; thenThrow/doThrow #  Rather than returning values, stubs can throw errors. Mockito lets exceptions be specified with one of two approaches:\nval mockedFile = mock(File::class.java) `when`(mockedFile.read()).thenThrow(RuntimeException()) doThrow(RuntimeException()).`when`(mockedFile).read() MockK provides the throws infix method to throw in stubs.\nval mockedFile = mockk\u0026lt;File\u0026gt;() every { mockedFile.read() } throws RuntimeException() doNothing #  See Migrating from Mockito: void methods\nthenAnswer/then/doAnswer #  Mockito allows arbitrary callbacks to be used for stubs with the Answer interface. Answer only contains a single method, so Kotlin allows a function literal to be used instead through SAM conversion.\nval mockedFile = mock(File::class.java) `when`(mockedFile.write(any())).thenAnswer { invocation -\u0026gt; println(\u0026#34;called with arguments: \u0026#34; + invocation.arguments.joinToString()) Unit } `when`(mockedFile.write(any())).then { invocation -\u0026gt; println(\u0026#34;called with arguments: \u0026#34; + invocation.arguments.joinToString()) Unit } doAnswer { invocation -\u0026gt; println(\u0026#34;called with arguments: \u0026#34; + invocation.arguments.joinToString()) Unit }.`when`(mockedFile).write(any()) MockK provides an equivalent infix function that also uses function literals.\nval mockedFile = mockk\u0026lt;File\u0026gt;() every { mockedFile.write(any()) } answers { call -\u0026gt; println(\u0026#34;called with arguments: \u0026#34; + call.invocation.args.joinToString()) Unit } Consecutive calls #  Mockito additionally lets different return values be stubbed for the same method call, such as for mocking an iterator.\nval mockedFile = mock(File::class.java) // Chain multiple calls `when`(mockedFile.read()).thenReturn(\u0026#34;read 1\u0026#34;).thenReturn(\u0026#34;read 2\u0026#34;).thenReturn(\u0026#34;read 3\u0026#34;) // Shorthand `when`(mockedFile.read()).thenReturn(\u0026#34;read 1\u0026#34;, \u0026#34;read 2\u0026#34;, \u0026#34;read 3\u0026#34;) doReturn(\u0026#34;read 1\u0026#34;, \u0026#34;read 2\u0026#34;, \u0026#34;read 3\u0026#34;).`when`(mockedFile).read() // Use different answer types `when`(mockedFile.read()) .thenReturn(\u0026#34;successful read\u0026#34;) .thenThrow(RuntimeException()) Additional answers is supported in MockK using various infix functions.\nval mockedFile = mockk\u0026lt;File\u0026gt;() // Chain multiple calls every { mockedFile.read() } returns \u0026#34;read 1\u0026#34; andThen \u0026#34;read 2\u0026#34; andThen \u0026#34;read 3\u0026#34; // Shorthand using a list every { mockedFile.read() } returnsMany listOf(\u0026#34;read 1\u0026#34;, \u0026#34;read 2\u0026#34;, \u0026#34;read 3\u0026#34;) every { mockedFile.read() } andThenMany listOf(\u0026#34;read 1\u0026#34;, \u0026#34;read 2\u0026#34;, \u0026#34;read 3\u0026#34;) // Use different answer types every { mockedFile.read() } returns \u0026#34;successful read\u0026#34; andThenThrows RuntimeException() Coroutines #  As MockK uses function literals to create stubs, small changes are needed to stub suspend functions. MockK provides functions prefixed with co as equivalents to other functions, such as coEvery and coAnswers. See Coroutines and suspend functions for more details.\nval mockedFile = mockk\u0026lt;File\u0026gt;() coEvery { mockedFile.readAsync() } returns \u0026#34;hello world\u0026#34; coEvery { mockedFile.writeAsync(any()) } coAnswers { call -\u0026gt; doAsyncWork() Unit } "});index.add({'id':2,'href':'/mockk-guidebook/docs/matching/equal/','title':"Check equality",'section':"Argument matching",'content':"Checking equality #   eq/neq isNull refEq/nrefEq  "});index.add({'id':3,'href':'/mockk-guidebook/docs/mocking/stubbing/','title':"Stub out behaviour",'section':"Mocking",'content':"Stub out behaviour #  Your Kotlin classes often depends on other objects and functions when running. When you are writing tests for your classes, you only want to test the class itself and not the dependency. MockK helps you create pretend versions of those dependencies instead of using the real versions.\nStubbing allows you to setup canned answers when functions are called. You only need to stub methods that are called by your class, and you can ignore methods that aren\u0026rsquo;t run during your test.\ninterface Navigator { val currentLocation: String fun navigateTo(newLocation: String): Unit } Here is an example of how to create a stub of the Navigator interface.\nimport io.mockk.every import io.mockk.mockk val navigator = mockk\u0026lt;Navigator\u0026gt;() every { navigator.currentLocation } returns \u0026#34;Home\u0026#34; every { navigator.navigateTo(\u0026#34;Park\u0026#34;) } throws IllegalStateException(\u0026#34;Can\u0026#39;t reach the park\u0026#34;) // prints \u0026#34;Home\u0026#34; println(navigator.currentLocation) // throws an IllegalStateException navigator.navigateTo(\u0026#34;Park\u0026#34;) In MockK, stubs are created by using the mockk and every functions. mockk creates your pretend object, and every lets you define canned answers for different functions on that pretend object. every starts a stubbing block and uses anonymous functions and infix functions to define the stub.\nInside the stubbing block (between the opening curly bracket { and closing curly bracket }), you write the method you want to provide a canned answer for. { navigator.currentLocation } tells MockK to make a canned answer for the currentLocation getter on the navigator object.\nTo define what happens when the stubbed method is called, an answer function such as returns is used. returns \u0026quot;Home\u0026quot; tells MockK to always return the string \u0026quot;Home\u0026quot; when the currentLocation getter is called.\nInstead to returning successful values, stubbed methods can throw errors. throws indicates that the following value should be an exception to throw, rather than a value to return. When the stubbed method is called in your tests, it will always throw the given exception instance.\n"});index.add({'id':4,'href':'/mockk-guidebook/docs/getting-started/why-mocking/','title':"Why use mocks",'section':"Getting Started",'content':"Why use mocks #  "});index.add({'id':5,'href':'/mockk-guidebook/docs/mockito-migrate/eq/','title':"`eq`",'section':"Migrating from Mockito",'content':"eq #  By default, Mockito verifies argument values by using the equals() method, which corresponds to == in Kotlin.\nverify(mock.containsAll(listOf(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;), true)) However, once argument matchers like any() are used, then the eq argument matcher must be used for literal values.\nverify(mock.containsAll(eq(listOf(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;)), anyBoolean())) In MockK, eq is always used as the default argument matcher. You can mix literal values with any without issue.\nverify { mock.containsAll(listOf(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, any())) } TODO:\n refEq same  "});index.add({'id':6,'href':'/mockk-guidebook/docs/matching/any/','title':"Allow any argument",'section':"Argument matching",'content':"Allowing any argument #   any allAny  "});index.add({'id':7,'href':'/mockk-guidebook/docs/mocking/verify/','title':"Verify that functions were called",'section':"Mocking",'content':"Verify that functions were called #  When using mocked dependencies, you usually want to test that your code calls the correct functions. In MockK, this is accomplished using the verify function.\nUsing verify to verify that a function was called looks a lot like using every for stubbing. A simple example is to call a method and immediately check that it was called.\nimport io.mockk.every import io.mockk.mockk import io.mockk.verify val navigator = mockk\u0026lt;Navigator\u0026gt;() every { navigator.navigateTo(any()) } returns Unit navigator.navigateTo(\u0026#34;Park\u0026#34;) verify { navigator.navigateTo(\u0026#34;Park\u0026#34;) } Similar to stubbing with every, verify starts a verification block and uses anonymous functions and infix functions to define what will be verified. verify supports the same argument matchers as every, along with a few additional matchers.\nInside the verification block (between the opening curly bracket { and closing curly bracket }), you write the method you want to verify. { navigator.navigateTo(\u0026quot;Park\u0026quot;) } tells MockK to check if the navigateTo method on the navigator object was called with the argument \u0026quot;Park\u0026quot;.\nVerifying dependencies #  In the previous simple example, verification isn\u0026rsquo;t very helpful as it just checks that the previous line ran. Verification becomes more useful when you are testing other classes, that depend on mocked instances. Let\u0026rsquo;s start testing a button.\nclass Button { private var clickListener: (() -\u0026gt; Unit)? = null fun setOnClickListener(listener: () -\u0026gt; Unit) { clickListener = listener } fun performClick() { clickListener?.invoke() } } class NavigationView( private val navigator: Navigator ) { val goToParkButton = Button() init { goToParkButton.setOnClickListener { navigator.navigate(\u0026#34;Park\u0026#34;) } } } A test for the above NavigationView class should check that clicking the goToParkButton tells the navigator to go to the park. If the navigator doesn\u0026rsquo;t record where it goes, then it can be difficult to check that the button does its job correctly. This is a scenario where MockK can shine.\n// Mock the dependency needed for navigationView val navigator = mockk\u0026lt;Navigator\u0026gt;() every { navigator.navigateTo(any()) } returns Unit // Create the navigation view to test val navigationView = NavigationView(navigator) // Test the button in navigation view navigationView.goToParkButton.performClick() verify { navigator.navigateTo(\u0026#34;Park\u0026#34;) } This test ensures that the button tells the navigator to go where we expect. If the NavigationView view gets changed in the future, the test will throw if this expectation is broken.\ngoToParkButton.setOnClickListener { - navigator.navigate(\u0026#34;Park\u0026#34;) + navigator.navigate(\u0026#34;Parka\u0026#34;)  } navigationView.goToParkButton.performClick() // Throws as navigateTo(\u0026#34;Park\u0026#34;) was never called. // MockK will mention in the error that navigateTo(\u0026#34;Parka\u0026#34;) was called. verify { navigator.navigateTo(\u0026#34;Park\u0026#34;) } Verifying that any mock functions is never called #  verify { navigator wasNot Called } Verifying that a function is never called #  verify(inverse = true) { navigator.navigateTo(\u0026#34;Park\u0026#34;) } verify(exactly = 0) { navigator.navigateTo(\u0026#34;Park\u0026#34;) } Verifying a function is called a certain number of times #  TODO: exactly\nUsing a range #  TODO: atLeast, atMost\nVerifying multiple functions #  TODO: ordering, verifyAll,\nConfirming all calls were verified #  TODO: confirmVerified, excludeRecords\n"});index.add({'id':8,'href':'/mockk-guidebook/docs/getting-started/why-mockk/','title':"Why MockK?",'section':"Getting Started",'content':"Why MockK #  MockK is a mocking framework built in Kotlin to be used with Kotlin programs. Because MockK is written in Kotlin, it has first-class support for Kotlin language features such as singleton objects, extension functions, and final classes.\n"});index.add({'id':9,'href':'/mockk-guidebook/docs/mockito-migrate/any/','title':"`any*`",'section':"Migrating from Mockito",'content':"any* #  When creating a stub or verifying a call, Mockito provides many different argument matchers. Besides eq, the most commonly used are the \u0026ldquo;any\u0026rdquo; family: any, anyBoolean, anyByte, anyChar, anyDouble, anyFloat, anyInt, anyLong, anyObject, anyShort, and anyString. In MockK, these variations are all replaced by a single any matcher.\n// TODO example class that takes object, int, string parameters. Show stub \u0026amp; verify for both libs. If you want to check for any null value, or any not-null value, the isNull matcher can be used.\nTODO: isNull(), isNull(inverse = true)\nTODO: ofType\n"});index.add({'id':10,'href':'/mockk-guidebook/docs/matching/oftype/','title':"Argument of a certain type",'section':"Argument matching",'content':"Argument of a certain type #   ofType  "});index.add({'id':11,'href':'/mockk-guidebook/docs/mocking/relax/','title':"Automatically stub by relaxing",'section':"Mocking",'content':"Automatically stub by relaxing #  If a method has not been stubbed, MockK will throw an error if it is called. This is designed to help make your tests easier to debug, as you\u0026rsquo;ll know if you forgot to mock a method.\ninterface Navigator { val currentLocation: String fun navigateTo(newLocation: String): Unit } val navigator = mockk\u0026lt;Navigator\u0026gt;() every { navigator.currentLocation } returns \u0026#34;Home\u0026#34; // prints \u0026#34;Home\u0026#34; println(navigator.currentLocation) // throws an error navigator.navigateTo(\u0026#34;Store\u0026#34;) For more complicated objects, you can tell MockK to return simple values for all methods that have not been stubbed, rather than throwing. This is done by using the relaxed parameter when calling the mockk function.\nval navigator = mockk\u0026lt;Navigator\u0026gt;(relaxed = true) every { navigator.currentLocation } returns \u0026#34;Home\u0026#34; // prints \u0026#34;Home\u0026#34; println(navigator.currentLocation) // does nothing navigator.navigateTo(\u0026#34;Store\u0026#34;) If desired, you can choose to only relax methods that return Unit. This lets you pre-stub methods that just trigger side-effects rather than returning a value.\nval navigator = mockk\u0026lt;Navigator\u0026gt;(relaxUnitFun = true) "});index.add({'id':12,'href':'/mockk-guidebook/docs/mockito-migrate/verify/','title':"`verify`",'section':"Migrating from Mockito",'content':"verify #  Verifying that a method was called has similar syntax in Mockito and MockK. MockK uses inline functions and keyword arguments in place of Mockito\u0026rsquo;s verification modes.\n// Mockito val mockedFile = mock(File::class.java) mockedFile.read() verify(mockedFile).read() // MockK val mockedFile = mockk\u0026lt;File\u0026gt;() mockedFile.read() verify { mockedFile.read() } Verification Mode #  Mockito lets extra arguments such as never() be passed to verify in the second parameter, all of which implement a VerificationMode interface. MockK has equivalents for these modes as keyword arguments in verify.\nnever #  // Mockito verify(mockedFile, never()).write() // MockK verify(inverse = true) { mockedFile.write() } atLeast/atLeastOnce #  // Mockito verify(mockedFile, atLeast(3)).read() verify(mockedFile, atLeastOnce()).write() // MockK verify(atLeast = 3) { mockedFile.read() } verify(atLeast = 1) { mockedFile.write() } atMost/atMostOnce #  // Mockito verify(mockedFile, atMost(3)).read() verify(mockedFile, atMostOnce()).write() // MockK verify(atMost = 3) { mockedFile.read() } verify(atMost = 1) { mockedFile.write() } times #  // Mockito verify(mockedFile, times(3)).read() // MockK verify(exactly = 3) { mockedFile.read() } timeout #  // Mockito verify(mockedFile, timeout(100)).readAsync() // MockK verify(timeout = 100) { mockedFile.readAsync() } verifyNoInteractions #  // Mockito verifyNoInteractions(mockOne) verifyNoInteractions(mockTwo, mockThree) // MockK verify { mockOne wasNot Called } verify { listOf(mockTwo, mockThree) wasNot Called } verifyNoMoreInteractions #  // Mockito verifyNoMoreInteractions(mockOne, mockTwo) // MockK confirmVerified(mockOne, mockTwo) Coroutines #  As MockK uses function literals to create stubs, small changes are needed to verify suspend functions. MockK provides functions prefixed with co as equivalents to other functions, such as coVerify. See Coroutines and suspend functions for more details.\nval mockedFile = mockk\u0026lt;File\u0026gt;() coVerify { mockedFile.readAsync() } "});index.add({'id':13,'href':'/mockk-guidebook/docs/matching/with/','title':"Assertions with an argument",'section':"Argument matching",'content':"Run assertions with an argument #   withArg withNullableArg coWithArg coWithNullableArg  There are some special argument matchers that can only be used when verifying that a mocked function was called. withArg and its variants allow you to capture an argument and run your own assertions on it without the need to set up a capturing slot.\ndata class File( val name: String, val data: ByteArray ) interface FileNetwork { fun download(name: String): File fun upload(file: File) } When using a capturing slot, testing the FileNetwork.download function looks like this:\nval network = mockk\u0026lt;FileNetwork\u0026gt;() val slot = slot\u0026lt;String\u0026gt;() every { network.download(capture(slot)) } returns mockk() network.download(\u0026#34;testfile\u0026#34;) verify { network.download(any()) } assertTrue(\u0026#34;testfile\u0026#34; == slot.captured) withArg simplifies this code so no slot is needed.\nval network = mockk\u0026lt;FileNetwork\u0026gt;() every { network.download(any()) } returns mockk() network.download(\u0026#34;testfile\u0026#34;) verify { network.download(withArg { assertTrue(\u0026#34;testfile\u0026#34; == it) }) } Arrays and data classes #  withArg can be helpful when you use arguments that aren\u0026rsquo;t easily compared, such as a data class containing arrays. The equals() function on an array works differently than on a List. Arrays are only equal if you compare with the exact same instance, while lists are equal if all of their items are equal. Since Kotlin data classes use the equals() function with each property, this array behaviour affects them.\nval expected = File(\u0026#34;hello\u0026#34;, data = \u0026#34;world\u0026#34;.toByteArray()) network.upload(File(\u0026#34;hello\u0026#34;, data = \u0026#34;world\u0026#34;.toByteArray())) // fails because the Files are not equal verify { network.upload(expected) } In your test, you can choose to compare properties individually using withArg.\nval expected = File(\u0026#34;hello\u0026#34;, data = \u0026#34;world\u0026#34;.toByteArray()) network.upload(File(\u0026#34;hello\u0026#34;, data = \u0026#34;world\u0026#34;.toByteArray())) verify { network.upload(withArg { assertTrue(expected.name == it.name) assertTrue(expected.data contentEquals it.data) }) } Nullable arguments #  withNullableArg is also provided by MockK when you wish to use it with a nullable argument.\nCoroutines #  MockK provides variants with withArg and withNullableArg that allow coroutine code to be executed. These variants are coWithArg and coWithNullableArg. If your assertions call a suspend function, these variants should be used.\n"});index.add({'id':14,'href':'/mockk-guidebook/docs/mocking/spy/','title':"Spy on existing classes",'section':"Mocking",'content':"Spy on existing classes #  Rather than mocking an object, you can create spies of real objects. Spies will run the real methods in a class, unlike mocks which don\u0026rsquo;t run anything. Stubbing methods on a spy will run the stub instead, so you can have a mixture of real methods and stubbed methods.\nSpies get their name because you can spy on the code you\u0026rsquo;re testing and see what methods it called. Spies let you verify that a method is called, just like a mock.\n"});index.add({'id':15,'href':'/mockk-guidebook/docs/mockito-migrate/arg-that/','title':"`argThat`",'section':"Migrating from Mockito",'content':" argThat -\u0026gt; match  "});index.add({'id':16,'href':'/mockk-guidebook/docs/mocking/coroutines/','title':"Coroutines and suspend functions",'section':"Mocking",'content':"Coroutines and suspend functions #  As MockK uses function literals to create stubs, small changes are needed to stub suspend functions. MockK provides functions prefixed with co as equivalents to other functions, such as coEvery and coAnswers.\nval mockedFile = mockk\u0026lt;File\u0026gt;() coEvery { mockedFile.readAsync() } returns \u0026#34;hello world\u0026#34; coEvery { mockedFile.writeAsync(any()) } coAnswers { call -\u0026gt; doAsyncWork() Unit } "});index.add({'id':17,'href':'/mockk-guidebook/docs/matching/custom/','title':"Custom matching functions",'section':"Argument matching",'content':"Custom matching functions #   match coMatch matchNullable coMatchNullable  "});index.add({'id':19,'href':'/mockk-guidebook/docs/matching/capture/','title':"Capture arguments to check later",'section':"Argument matching",'content':"Capturing arguments to check later #   capture captureNullable captureLambda captureCoroutine invoke/coInvoke (maybe?)  "});index.add({'id':20,'href':'/mockk-guidebook/docs/mocking/constructor/','title':"Mock constructors in code you don't own",'section':"Mocking",'content':"Mock constructors in code you don\u0026rsquo;t own #  Sometimes your classes have dependencies that they construct themselves. While it\u0026rsquo;s best to use a system like dependency injection to avoid this, MockK makes it possible to control constructors and make them return a mocked instance.\nThe mockkConstructor(T::class) function takes in a class reference. Once used, every constructor of that type will start returning a singleton that can be mocked. Rather than building a new instance every time the constructor is called, MockK generates a singleton and always returns the same instance. This will apply to all constructors for a given class, there is no way to distinguish between them.\nThe mocked result can be obtained by using anyConstructed\u0026lt;T\u0026gt;(). Using this function, stubbing and verification can be done just like any other mock.\nUnmocking #  If you\u0026rsquo;d like to revert back to the real constructor, you can use the unmockkConstructor method. This removes any stubbed behaviour you may have added.\n"});index.add({'id':21,'href':'/mockk-guidebook/docs/mockito-migrate/void/','title':"`void` methods",'section':"Migrating from Mockito",'content':"void methods #  Mockito\u0026rsquo;s when method doesn\u0026rsquo;t work with void methods. To create a stub that doesn\u0026rsquo;t return anything, the doNothing method is used.\nval mockedFile = mock(File::class.java) doNothing().`when`(mockedFile).write(any()) MockK doesn\u0026rsquo;t have any restrictions with these methods, as they return Unit in Kotlin. As a result, the standard returns infix function can be used.\nval mockedFile = mockk\u0026lt;File\u0026gt;() every { mockedFile.write(any()) } returns Unit MockK also provides the justRun method as a shorthand for every { x } returns Unit. For more information, see the Returning Unit tip.\nval mockedFile = mockk\u0026lt;File\u0026gt;() justRun { mockedFile.write(any()) } "});index.add({'id':22,'href':'/mockk-guidebook/docs/mocking/static/','title':"Mock singleton objects and static methods",'section':"Mocking",'content':"Mock singleton objects and static methods #  Mocking objects #  When you need a singleton in Kotlin, you can use an object. These specialized classes will only ever have one instance, so you can\u0026rsquo;t mock them in the usual manner. Instead, MockK provides specialized functions to create object mocks.\nobject FeatureFlags { val featureEnabled = true } mockkObject(FeatureFlags) every { FeatureFlags.featureEnabled } returns false // prints false println(FeatureFlags.featureEnabled) Despite the name, object mocks behave more like spies. If a method is not stubbed, then the real method will be called. This differs from regular mocks, where a method will either throw or do nothing if it is not stubbed.\nclass Calculator1 { fun add(a: Int, b: Int) { return a + b } } object Calculator2 { fun add(a: Int, b: Int) { return a + b } } val calculator1 = mockk\u0026lt;Calculator1\u0026gt;() mockkObject(Calculator2) // throws because the method was not stubbed println(calculator1.add(2, 2)) // returns the result from the real method println(Calculator2.add(2, 2)) This approach works with any Kotlin object, which includes companion objects and enum class elements.\nMocking static methods #  Sometimes you may end up working with Java code in your tests, which can have static methods.\npackage com.name.app; class Writer { public static File getFile(String path) { return File(path); } } Just like singleton objects, there will only ever be one version of static methods, so you cannot mock them in the usual manner. Again, MockK provides specialized functions to mock static methods.\nmockkStatic(\u0026#34;com.name.app.Writer\u0026#34;) Rather than passing a reference to the class, you pass the class name as a string. You can also choose to pass in a reference to the class, and MockK will figure out the class name.\nmockkStatic(Writer::class) Like object mocks, static mocks behave like spies. The real method will be called if the method is not stubbed.\nUnmocking #  If you\u0026rsquo;d like to revert back to the real object, you can use the unmockkObject method. This removes any stubbed behaviour you may have added.\nobject Calculator { fun add(a: Int, b: Int) { return a + b } } mockkObject(Calculator) every { Calculator.add(any(), any()) } returns 10 // prints 10 println(Calculator.add(2, 2)) unmockkObject(Calculator) // prints 4 println(Calculator.add(2, 2)) "});index.add({'id':23,'href':'/mockk-guidebook/docs/matching/vararg/','title':"Variable arguments",'section':"Argument matching",'content':"Variable arguments #   anyVararg varargAny varargAll any...Vararg varargAny... varargAll...  "});index.add({'id':24,'href':'/mockk-guidebook/docs/matching/compareto/','title':"Comparables",'section':"Argument matching",'content':"Comparables #   less more range cmpEq  MockK provides a few argument matchers for numbers and comparable objects. These matches all use the compareTo function to compare objects.\nmore #  Checks if the argument is more than the value given to the matcher. Valid arguments will return a negative number when compared to the matcher value.\nassertTrue(value.compareTo(arg) \u0026lt; 0) less #  Checks if the argument is less than the value given to the matcher. Valid arguments will return a positive number when compared to the matcher value.\nassertTrue(value.compareTo(arg) \u0026gt; 0) cmpEq #  Checks if the argument is equal to the value given to the matcher, according to the compareTo function. Valid arguments will return 0 when compared to the matcher value.\nassertTrue(value.compareTo(arg) == 0) range #  TODO\n"});index.add({'id':25,'href':'/mockk-guidebook/docs/mocking/extension/','title':"Mock top-level and extension functions",'section':"Mocking",'content':"Mock top-level and extension functions #  Top-level functions #  Kotlin lets you write functions that don\u0026rsquo;t belong to any class or object, called top-level functions. These calls are translated to static methods in Java, and a special Java class is generated to hold the functions. These top-level functions can be mocked using mockkStatic, but you need to figure out the class name of this generated Java class.\nFinding the class name #  TODO\nExtension functions #  Depending on where an extension function is located, it may correspond to a top-level function or a class member. If placed inside a class, the extension function is attached to that class and can be mocked using the with method.\n// TODO val mock = ...  with (mock) { every { any\u0026lt;Type\u0026gt;().extensionFunction() } returns \u0026#34;result\u0026#34; } If the extension function is inside an object, the code is similar but the object needs to be mocked first.\nWhen the extension function is in the top-level of a file, it can be mocked like other top-level functions using mockkStatic.\n"});index.add({'id':26,'href':'/mockk-guidebook/docs/mocking/clear/','title':"Clear state",'section':"Mocking",'content':"Clear state #  "});index.add({'id':27,'href':'/mockk-guidebook/docs/matching/combine/','title':"Combine matchers",'section':"Argument matching",'content':"Combining matchers #   and or not  "});index.add({'id':28,'href':'/mockk-guidebook/docs/mocking/annotation/','title':"Create many mocks quickly with annotations",'section':"Mocking",'content':"Create many mocks quickly with annotations #  Sometimes you will need to create many mocks in your test class. As each mock needs to be declared as a property in the test class, then initialized in the test setup function, the amount of code needed to build all your mocks can grow very quickly. MockK provides a shorthand using annotations to make this simpler.\nclass RepositoryTest { @MockK private lateinit var foodDatabase: FoodDatabase @MockK private lateinit var recipeDatabase: RecipeDatabase @MockK private lateinit var networkClient: NetworkClient @SpyK private var logger = Logger() @Before fun setup() { MockKAnnotations.init(this) } @Test fun testDatabaseAndNetwork() { // ... use foodDatabase, recipeDatabase, networkClient and debugger  } } Each property with the @MockK annotation is automatically mocked and ready to use in tests. This reduces repetition and makes your tests more readable. The above class is equivalent to:\nclass RepositoryTest { private lateinit var foodDatabase: FoodDatabase private lateinit var recipeDatabase: RecipeDatabase private lateinit var networkClient: NetworkClient private lateinit var logger: Logger @Before fun setup() { foodDatabase = mockk() recipeDatabase = mockk() networkClient = mockk() logger = spyk(Logger()) } @Test fun testDatabaseAndNetwork() { // ... use foodDatabase, recipeDatabase, networkClient and debugger  } } Options #  @MockK annotations take the same options as the mockk function. If you wish to use a relaxed mock, the annotation looks similar to the equivalent mockk call:\n// Annotations class RepositoryTest { @MockK(relaxed = true) private lateinit var foodDatabase: FoodDatabase @MockK(relaxUnitFun = true) private lateinit var recipeDatabase: RecipeDatabase @Before fun setup() { MockKAnnotations.init(this) } } // Long form class RepositoryTest { private lateinit var foodDatabase: FoodDatabase private lateinit var recipeDatabase: RecipeDatabase @Before fun setup() { foodDatabase = mockk(relaxed = true) recipeDatabase = mockk(relaxUnitFun = true) } } In addition to @MockK(relaxed = true), there is an equivalent @RelaxedMockK annotation.\nIf options are shared across every annotated mock, they can be passed to the init call instead.\nclass RepositoryTest { @MockK private lateinit var foodDatabase: FoodDatabase @MockK private lateinit var recipeDatabase: RecipeDatabase @Before fun setup() { MockKAnnotations.init(this, relaxed = true) } } Spies #  TODO\n"});index.add({'id':31,'href':'/mockk-guidebook/docs/getting-started/','title':"Getting Started",'section':"Docs",'content':"Getting Started #    Why use mocks   (TODO) I thought lying was bad!   Why MockK?   (TODO) About the MockK framework.   "});index.add({'id':32,'href':'/mockk-guidebook/docs/quick/android/','title':"Android",'section':"Docs",'content':"Android Quickstart #  MockK works great with Android and allows you to mock objects in both your Android unit tests and instrumented tests. MockK can handle mocking Context, static functions, and more to help you test your Android code.\nTo install MockK, all you need to do is add it as a dependency in your module\u0026rsquo;s Gradle file. In most Android Studio projects, this file is located at app/build.gradle. Once you open the file, search for the dependencies block and add a new line.\ndependencies { ... testImplementation \u0026#34;io.mockk:mockk:$mockk_version\u0026#34; } $mockk_version should be replaced with the version of MockK you wish to use. The latest version is listed on the Maven website.\nAfter syncing your project with Gradle files, MockK will be available for use in your unit tests (located in app/src/test). To use MockK in your instrumented tests (located in app/src/androidTest), an additional line is needed in your module\u0026rsquo;s Gradle file.\ndependencies { ... androidTestImplementation \u0026#34;io.mockk:mockk-android:$mockk_version\u0026#34; } Unlike unit tests, instrumented tests are run live on an Android device or emulator.\nTODO add differences between versions\n"});index.add({'id':35,'href':'/mockk-guidebook/docs/tips/timeout/','title':"Timeout",'section':"TIPs",'content':"Timeouts #  "});index.add({'id':36,'href':'/mockk-guidebook/docs/tips/unit/','title':"Unit",'section':"TIPs",'content':"Return Unit #  When stubbing a function that returns nothing, MockK provides a few shortcuts.\nval logger = mockk\u0026lt;Logger\u0026gt;() every { logger.log(any()) } returns Unit every { logger.log(any()) } answers { Unit } every { logger.log(any()) } just Runs justRun { logger.log(any()) } just Runs is the nicest to use, since its shorter than returns and answers and additionally works with coEvery.\ncoEvery { logger.log(any()) } just Runs "});index.add({'id':37,'href':'/mockk-guidebook/docs/matching/','title':"Argument matching",'section':"Docs",'content':"Argument matching #  Argument matchers are placeholders use to specify what values can be used in a function. They can be used with stubs and verification.\n  Check equality   (TODO) Checking if an argument is equal using eq, refEq, isNull, and more.   Allow any argument   (TODO) anything goes here.   Argument of a certain type   (TODO) Don\u0026rsquo;t allow anyone, just arguments that are ofType.   Assertions with an argument   Using withArg to run assertions in verify calls.   Custom matching functions   (TODO) Adding additional matchers with the match function.   Capture arguments to check later   (TODO) capture arguments out of stubs and verify calls into a slot.   Variable arguments   (TODO) Matching variable arguments with anyVararg and more.   Comparables   Matching smaller numbers, bigger numbers, and more.   Combine matchers   (TODO) Logical operators and, or, not for matchers.   "});index.add({'id':39,'href':'/mockk-guidebook/docs/mockito-migrate/','title':"Migrating from Mockito",'section':"Docs",'content':"Migrating from Mockito #  Learn how to use MockK by seeing equivalents to functions in Mockito.\n  Create a mock   The similarities and differences in creating mocks between Mockito and MockK.   `when` and `do*`   when(x).thenReturn(y), doReturn, and more.   `eq`   Mockito\u0026rsquo;s eq, refEq, and same argument matchers.   `any*`   The \u0026ldquo;any\u0026rdquo; family of matchers: any, anyBoolean, anyByte, anyChar, anyDouble, anyFloat, anyInt, anyLong, anyObject, anyShort, and anyString.   `verify`   verify that a method was called.   `argThat`   (TODO) Porting custom matchers with argThat   ArgumentCaptor   (TODO) Capturing arguments to check them later.   `void` methods   MockK makes it easier to mock methods that return void.   "});index.add({'id':40,'href':'/mockk-guidebook/docs/mocking/','title':"Mocking",'section':"Docs",'content':"Mocking #  Mocking start with one call, the mockk function. This function takes in a class and returns a fake version of it, where all functions are present but will throw when called.\nimport io.mockk.mockk val mockedFile = mockk\u0026lt;File\u0026gt;()   Stub out behaviour   Using every and returns to define behaviour.   Verify that functions were called   Using verify to check that a function was used.   Automatically stub by relaxing   How to change the default mockk result with relaxed.   Spy on existing classes   Using spyk to mix mocks and real classes.   Coroutines and suspend functions   Using coEvery, coVerify, and more to mock coroutines.   Mock constructors in code you don\u0026#39;t own   Advanced mocking with mockkConstructor.   Mock singleton objects and static methods   Advanced static mocking with mockkStatic and mockkObject.   Mock top-level and extension functions   Mocking top-level functions with mockkStatic.   Clear state   (TODO) Clearing the state of a mock.   Create many mocks quickly with annotations   The @MockK and @SpyK shortcuts.   Chain mocks into hierarchies   (TODO) Building a mock with less code using lambdas.   Create more complicated answers for stubs   (TODO) Using answers when returns just isn\u0026rsquo;t enough.   "});index.add({'id':41,'href':'/mockk-guidebook/docs/tips/','title':"TIPs",'section':"Docs",'content':"TIPs #  In this section we present a number of tips that we have collected over the course of using MockK in the real world.\n  Chains     Exclude     Timeout   Timeouts #   Unit   Return Unit # When stubbing a function that returns nothing, MockK provides a few shortcuts. val logger = mockk\u0026lt;Logger\u0026gt;() every { logger.log(any()) } returns Unit every { logger.log(any()) } answers { Unit } every { logger.log(any()) } just Runs justRun { logger.log(any()) } just Runs is the nicest to use, since its shorter than returns and answers and additionally works with coEvery. coEvery { logger.log(any()) } just Runs   "});})();