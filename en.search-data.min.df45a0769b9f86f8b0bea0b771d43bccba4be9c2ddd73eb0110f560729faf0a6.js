'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/mockk-guidebook/docs/mockito-migrate/create-mock/',title:"Create a mock",section:"Migrating from Mockito",content:"Create a mock #  The syntax to create a mock is very similar in Mockito and MockK. However, the behaviour is slightly different.\n// Mockito val mockedFile = mock(File::class.java) mockedFile.read() // does nothing // MockK val mockedFile = mockk\u0026lt;File\u0026gt;() mockedFile.read() // throws because the method was not stubbed Mocked objects in MockK resemble Mockito\u0026rsquo;s STRICT_STUBS mode by default. If a method is not stubbed, then it will throw. This makes it easier to catch methods that are being called when you do not expect it, or when methods are being called with different arguments.\nMockito\u0026rsquo;s default lenient behaviour can be replicated with the relaxed setting. Relaxed mocks will have default stubs for all methods.\n// MockK val mockedFile = mockk\u0026lt;File\u0026gt;(relaxed = true) mockedFile.read() // will not throw If desired, you can choose to only relax methods that return Unit.\n// MockK val mockedFile = mockk\u0026lt;File\u0026gt;(relaxUnitFun = true) mockedFile.read() // returns Unit, will not throw mockedFile.exists() // throws as the method returns Boolean "}),a.add({id:1,href:'/mockk-guidebook/docs/mockito-migrate/when/',title:"`when` and `do*`",section:"Migrating from Mockito",content:"when and do* #  Mockito provides two similar approaches for stubbing behaviour on a mock: the when method and the do* family of methods.\nMost stubs in Mockito are written with when at the beginning of the line, following the format \u0026ldquo;when the method is called then return something\u0026rdquo;. Stubs written with the when method look like this:\nval mockedFile = mock(File::class.java) `when`(mockedFile.read()).thenReturn(\u0026#34;hello world\u0026#34;) Sometimes this syntax cannot be used in Mockito, so an alternative approach is available. doReturn and the related doThrow, doAnswer, doNothing, and doCallRealMethod methods are used for void methods, spies, and other occasions where the when method cannot be used. Stubs written with the do* family of methods look like this:\nval mockedFile = mock(File::class.java) doReturn(\u0026#34;hello world\u0026#34;).`when`(mockedFile).read() In MockK, all stubs can be written with the every method. every starts a stubbing block and uses anonymous functions and infix functions to define the stub. The syntax looks like this:\nval mockedFile = mockk\u0026lt;File\u0026gt;() every { mockedFile.read() } returns \u0026#34;hello world\u0026#34; MockK provides alternatives for many types of answers that Mockito supports for stubbing.\nthenReturn/doReturn #  Returning a value is probably the most common stub to create. In Mockito, the syntax can look like one of two approaches:\nval mockedFile = mock(File::class.java) `when`(mockedFile.read()).thenReturn(\u0026#34;hello world\u0026#34;) doReturn(\u0026#34;hello world\u0026#34;).`when`(mockedFile).read() In MockK, an infix function is used instead.\nval mockedFile = mockk\u0026lt;File\u0026gt;() every { mockedFile.read() } returns \u0026#34;hello world\u0026#34; thenThrow/doThrow #  Rather than returning values, stubs can throw errors. Mockito lets exceptions be specified with one of two approaches:\nval mockedFile = mock(File::class.java) `when`(mockedFile.read()).thenThrow(RuntimeException()) doThrow(RuntimeException()).`when`(mockedFile).read() MockK provides the throws infix method to throw in stubs.\nval mockedFile = mockk\u0026lt;File\u0026gt;() every { mockedFile.read() } throws RuntimeException() doNothing #  See Migrating from Mockito: void methods\nthenAnswer/then/doAnswer #  Mockito allows arbitrary callbacks to be used for stubs with the Answer interface. Answer only contains a single method, so Kotlin allows a function literal to be used instead through SAM conversion.\nval mockedFile = mock(File::class.java) `when`(mockedFile.write(any())).thenAnswer { invocation -\u0026gt; println(\u0026#34;called with arguments: \u0026#34; + invocation.arguments.joinToString()) Unit } `when`(mockedFile.write(any())).then { invocation -\u0026gt; println(\u0026#34;called with arguments: \u0026#34; + invocation.arguments.joinToString()) Unit } doAnswer { invocation -\u0026gt; println(\u0026#34;called with arguments: \u0026#34; + invocation.arguments.joinToString()) Unit }.`when`(mockedFile).write(any()) MockK provides an equivalent infix function that also uses function literals.\nval mockedFile = mockk\u0026lt;File\u0026gt;() every { mockedFile.write(any()) } answers { call -\u0026gt; println(\u0026#34;called with arguments: \u0026#34; + call.invocation.args.joinToString()) Unit } Consecutive calls #  Mockito additionally lets different return values be stubbed for the same method call, such as for mocking an iterator.\nval mockedFile = mock(File::class.java) // Chain multiple calls `when`(mockedFile.read()).thenReturn(\u0026#34;read 1\u0026#34;).thenReturn(\u0026#34;read 2\u0026#34;).thenReturn(\u0026#34;read 3\u0026#34;) // Shorthand `when`(mockedFile.read()).thenReturn(\u0026#34;read 1\u0026#34;, \u0026#34;read 2\u0026#34;, \u0026#34;read 3\u0026#34;) doReturn(\u0026#34;read 1\u0026#34;, \u0026#34;read 2\u0026#34;, \u0026#34;read 3\u0026#34;).`when`(mockedFile).read() // Use different answer types `when`(mockedFile.read()) .thenReturn(\u0026#34;successful read\u0026#34;) .thenThrow(RuntimeException()) Additional answers is supported in MockK using various infix functions.\nval mockedFile = mockk\u0026lt;File\u0026gt;() // Chain multiple calls every { mockedFile.read() } returns \u0026#34;read 1\u0026#34; andThen \u0026#34;read 2\u0026#34; andThen \u0026#34;read 3\u0026#34; // Shorthand using a list every { mockedFile.read() } returnsMany listOf(\u0026#34;read 1\u0026#34;, \u0026#34;read 2\u0026#34;, \u0026#34;read 3\u0026#34;) every { mockedFile.read() } andThenMany listOf(\u0026#34;read 1\u0026#34;, \u0026#34;read 2\u0026#34;, \u0026#34;read 3\u0026#34;) // Use different answer types every { mockedFile.read() } returns \u0026#34;successful read\u0026#34; andThenThrows RuntimeException() Coroutines #  As MockK uses function literals to create stubs, small changes are needed to stub suspend functions. MockK provides functions prefixed with co as equivalents to other functions, such as coEvery and coAnswers. See Coroutines and suspend functions for more details.\nval mockedFile = mockk\u0026lt;File\u0026gt;() coEvery { mockedFile.readAsync() } returns \u0026#34;hello world\u0026#34; coEvery { mockedFile.writeAsync(any()) } coAnswers { call -\u0026gt; doAsyncWork() Unit } "}),a.add({id:2,href:'/mockk-guidebook/docs/matching/equal/',title:"Check equality",section:"Argument matching",content:"Checking equality #   eq/neq isNull refEq/nrefEq  "}),a.add({id:3,href:'/mockk-guidebook/docs/mocking/stubbing/',title:"Stub out behaviour",section:"Mocking",content:"Stub out behaviour #  Your Kotlin classes often depends on other objects and functions when running. When you are writing tests for your classes, you only want to test the class itself and not the dependency. MockK helps you create pretend versions of those dependencies instead of using the real versions.\nStubbing allows you to setup canned answers when functions are called. You only need to stub methods that are called by your class, and you can ignore methods that aren\u0026rsquo;t run during your test.\ninterface Navigator { val currentLocation: String fun navigateTo(newLocation: String): Unit } Here is an example of how to create a stub of the Navigator interface.\nimport io.mockk.every import io.mockk.mockk val navigator = mockk\u0026lt;Navigator\u0026gt;() every { navigator.currentLocation } returns \u0026#34;Home\u0026#34; every { navigator.navigateTo(\u0026#34;Park\u0026#34;) } throws IllegalStateException(\u0026#34;Can\u0026#39;t reach the park\u0026#34;) // prints \u0026#34;Home\u0026#34; println(navigator.currentLocation) // throws an IllegalStateException navigator.navigateTo(\u0026#34;Park\u0026#34;) In MockK, stubs are created by using the mockk and every functions. mockk creates your pretend object, and every lets you define canned answers for different functions on that pretend object. every starts a stubbing block and uses anonymous functions and infix functions to define the stub.\nInside the stubbing block (between the opening curly bracket { and closing curly bracket }), you write the method you want to provide a canned answer for. { navigator.currentLocation } tells MockK to make a canned answer for the currentLocation getter on the navigator object.\nTo define what happens when the stubbed method is called, an answer function such as returns is used. returns \u0026quot;Home\u0026quot; tells MockK to always return the string \u0026quot;Home\u0026quot; when the currentLocation getter is called.\nInstead to returning successful values, stubbed methods can throw errors. throws indicates that the following value should be an exception to throw, rather than a value to return. When the stubbed method is called in your tests, it will always throw the given exception instance.\n"}),a.add({id:4,href:'/mockk-guidebook/docs/getting-started/why-mocking/',title:"Why use mocks",section:"Getting Started",content:"Why use mocks #  How do you make sure your code runs like it\u0026rsquo;s supposed to? You can start out building your app, playing around with it, and trying buttons while ensuring there are no crashes. However, as your codebase grows, testing every edge case for every function becomes more difficult to do manually. Enter automated testing: code that runs your app with pre-written instructions then checks that the result matches your expectation.\nMost automated tests are unit tests: tests that check a single function at a time, rather than the entire app. \u0026ldquo;Units\u0026rdquo; refer to parts of your code that can be tested in isolation. This may be a standalone function or a single class.\nHowever, classes usually depend on other classes to run properly. A Car class may depend on an Engine class. You need to provide these dependencies for the Car to work, but it\u0026rsquo;s hard to write tests in isolation if you\u0026rsquo;re also configuring the Engine at the same time.\nYou can work around this problem by creating fake versions of the dependencies. These fake classes are called \u0026ldquo;mocks\u0026rdquo;. You can configure mocks in many different ways to be suitable for a variety of unit tests. They can throw an error if the tested class calls unexpected methods on the mock, or allow any methods to be called and automatically provide fake results. You have fine control over the behaviour of every method on a mock, so your test can handle all the possible edge cases.\nWriting unit tests will help you track down bugs ahead of time, and ensure they don\u0026rsquo;t reappear when you make changes to your code. Mocks are an important tool in your unit testing toolkit to help you write isolated tests. Read on to learn how to use the MockK mocking framework, or learn why you should use MockK over other frameworks.\n"}),a.add({id:5,href:'/mockk-guidebook/docs/mockito-migrate/eq/',title:"`eq`",section:"Migrating from Mockito",content:"eq #  By default, Mockito verifies argument values by using the equals() method, which corresponds to == in Kotlin.\nverify(mock.containsAll(listOf(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;), true)) However, once argument matchers like any() are used, then the eq argument matcher must be used for literal values.\nverify(mock.containsAll(eq(listOf(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;)), anyBoolean())) In MockK, eq is always used as the default argument matcher. You can mix literal values with any without issue.\nverify { mock.containsAll(listOf(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, any())) } TODO:\n refEq same  "}),a.add({id:6,href:'/mockk-guidebook/docs/matching/any/',title:"Allow any argument",section:"Argument matching",content:"Allowing any argument #   any allAny  "}),a.add({id:7,href:'/mockk-guidebook/docs/mocking/verify/',title:"Verify that functions were called",section:"Mocking",content:"Verify that functions were called #  When using mocked dependencies, you usually want to test that your code calls the correct functions. In MockK, this is accomplished using the verify function.\nUsing verify to verify that a function was called looks a lot like using every for stubbing. A simple example is to call a method and immediately check that it was called.\nimport io.mockk.every import io.mockk.mockk import io.mockk.verify val navigator = mockk\u0026lt;Navigator\u0026gt;() every { navigator.navigateTo(any()) } returns Unit navigator.navigateTo(\u0026#34;Park\u0026#34;) verify { navigator.navigateTo(\u0026#34;Park\u0026#34;) } Similar to stubbing with every, verify starts a verification block and uses anonymous functions and infix functions to define what will be verified. verify supports the same argument matchers as every, along with a few additional matchers.\nInside the verification block (between the opening curly bracket { and closing curly bracket }), you write the method you want to verify. { navigator.navigateTo(\u0026quot;Park\u0026quot;) } tells MockK to check if the navigateTo method on the navigator object was called with the argument \u0026quot;Park\u0026quot;.\nVerifying dependencies #  In the previous simple example, verification isn\u0026rsquo;t very helpful as it just checks that the previous line ran. Verification becomes more useful when you are testing other classes, that depend on mocked instances. Let\u0026rsquo;s start testing a button.\nclass Button { private var clickListener: (() -\u0026gt; Unit)? = null fun setOnClickListener(listener: () -\u0026gt; Unit) { clickListener = listener } fun performClick() { clickListener?.invoke() } } class NavigationView( private val navigator: Navigator ) { val goToParkButton = Button() init { goToParkButton.setOnClickListener { navigator.navigate(\u0026#34;Park\u0026#34;) } } } A test for the above NavigationView class should check that clicking the goToParkButton tells the navigator to go to the park. If the navigator doesn\u0026rsquo;t record where it goes, then it can be difficult to check that the button does its job correctly. This is a scenario where MockK can shine.\n// Mock the dependency needed for navigationView val navigator = mockk\u0026lt;Navigator\u0026gt;() every { navigator.navigateTo(any()) } returns Unit // Create the navigation view to test val navigationView = NavigationView(navigator) // Test the button in navigation view navigationView.goToParkButton.performClick() verify { navigator.navigateTo(\u0026#34;Park\u0026#34;) } This test ensures that the button tells the navigator to go where we expect. If the NavigationView view gets changed in the future, the test will throw if this expectation is broken.\ngoToParkButton.setOnClickListener { - navigator.navigate(\u0026#34;Park\u0026#34;) + navigator.navigate(\u0026#34;Parka\u0026#34;)  } navigationView.goToParkButton.performClick() // Throws as navigateTo(\u0026#34;Park\u0026#34;) was never called. // MockK will mention in the error that navigateTo(\u0026#34;Parka\u0026#34;) was called. verify { navigator.navigateTo(\u0026#34;Park\u0026#34;) } Verifying that any mock functions is never called #  verify { navigator wasNot Called } Verifying that a function is never called #  verify(inverse = true) { navigator.navigateTo(\u0026#34;Park\u0026#34;) } verify(exactly = 0) { navigator.navigateTo(\u0026#34;Park\u0026#34;) } Verifying a function is called a certain number of times #  verify(exactly = 1) { navigator.navigateTo(\u0026#34;Park\u0026#34;) } verify(atLeast = 1, atMost = 1) { navigator.navigateTo(\u0026#34;Park\u0026#34;) } Using a range #  verify(atLeast = 2, atMost = 3) { navigator.navigateTo(\u0026#34;Park\u0026#34;) } In the sample test will be green in the following cases:\n Function called two times Function called three times  Verifying multiple functions #  TODO: ordering, verifyAll, verifySequence, verifyOrder\nConfirming all calls were verified #  TODO: confirmVerified, excludeRecords\n"}),a.add({id:8,href:'/mockk-guidebook/docs/getting-started/why-mockk/',title:"Why MockK?",section:"Getting Started",content:"Why MockK #  MockK is a mocking framework built in Kotlin to be used with Kotlin programs. Because MockK is written in Kotlin, it has first-class support for Kotlin language features such as singleton objects, extension functions, and final classes.\n"}),a.add({id:9,href:'/mockk-guidebook/docs/mockito-migrate/any/',title:"`any*`",section:"Migrating from Mockito",content:"any* #  When creating a stub or verifying a call, Mockito provides many different argument matchers. Besides eq, the most commonly used are the \u0026ldquo;any\u0026rdquo; family: any, anyBoolean, anyByte, anyChar, anyDouble, anyFloat, anyInt, anyLong, anyObject, anyShort, and anyString. In MockK, these variations are all replaced by a single any matcher.\n// TODO example class that takes object, int, string parameters. Show stub \u0026amp; verify for both libs. If you want to check for any null value, or any not-null value, the isNull matcher can be used.\nTODO: isNull(), isNull(inverse = true)\nTODO: ofType\n"}),a.add({id:10,href:'/mockk-guidebook/docs/matching/oftype/',title:"Argument of a certain type",section:"Argument matching",content:"Argument of a certain type #   ofType  "}),a.add({id:11,href:'/mockk-guidebook/docs/mocking/relax/',title:"Automatically stub by relaxing",section:"Mocking",content:"Automatically stub by relaxing #  If a method has not been stubbed, MockK will throw an error if it is called. This is designed to help make your tests easier to debug, as you\u0026rsquo;ll know if you forgot to mock a method.\ninterface Navigator { val currentLocation: String fun navigateTo(newLocation: String): Unit } val navigator = mockk\u0026lt;Navigator\u0026gt;() every { navigator.currentLocation } returns \u0026#34;Home\u0026#34; // prints \u0026#34;Home\u0026#34; println(navigator.currentLocation) // throws an error navigator.navigateTo(\u0026#34;Store\u0026#34;) For more complicated objects, you can tell MockK to return simple values for all methods that have not been stubbed, rather than throwing. This is done by using the relaxed parameter when calling the mockk function.\nval navigator = mockk\u0026lt;Navigator\u0026gt;(relaxed = true) every { navigator.currentLocation } returns \u0026#34;Home\u0026#34; // prints \u0026#34;Home\u0026#34; println(navigator.currentLocation) // does nothing navigator.navigateTo(\u0026#34;Store\u0026#34;) If desired, you can choose to only relax methods that return Unit. This lets you pre-stub methods that just trigger side-effects rather than returning a value.\nval navigator = mockk\u0026lt;Navigator\u0026gt;(relaxUnitFun = true) "}),a.add({id:12,href:'/mockk-guidebook/docs/mockito-migrate/verify/',title:"`verify`",section:"Migrating from Mockito",content:"verify #  Verifying that a method was called has similar syntax in Mockito and MockK. MockK uses inline functions and keyword arguments in place of Mockito\u0026rsquo;s verification modes.\n// Mockito val mockedFile = mock(File::class.java) mockedFile.read() verify(mockedFile).read() // MockK val mockedFile = mockk\u0026lt;File\u0026gt;() mockedFile.read() verify { mockedFile.read() } Verification Mode #  Mockito lets extra arguments such as never() be passed to verify in the second parameter, all of which implement a VerificationMode interface. MockK has equivalents for these modes as keyword arguments in verify.\nnever #  // Mockito verify(mockedFile, never()).write() // MockK verify(inverse = true) { mockedFile.write() } atLeast/atLeastOnce #  // Mockito verify(mockedFile, atLeast(3)).read() verify(mockedFile, atLeastOnce()).write() // MockK verify(atLeast = 3) { mockedFile.read() } verify(atLeast = 1) { mockedFile.write() } atMost/atMostOnce #  // Mockito verify(mockedFile, atMost(3)).read() verify(mockedFile, atMostOnce()).write() // MockK verify(atMost = 3) { mockedFile.read() } verify(atMost = 1) { mockedFile.write() } times #  // Mockito verify(mockedFile, times(3)).read() // MockK verify(exactly = 3) { mockedFile.read() } timeout #  // Mockito verify(mockedFile, timeout(100)).readAsync() // MockK verify(timeout = 100) { mockedFile.readAsync() } verifyNoInteractions #  // Mockito verifyNoInteractions(mockOne) verifyNoInteractions(mockTwo, mockThree) // MockK verify { mockOne wasNot Called } verify { listOf(mockTwo, mockThree) wasNot Called } verifyNoMoreInteractions #  // Mockito verifyNoMoreInteractions(mockOne, mockTwo) // MockK confirmVerified(mockOne, mockTwo) Coroutines #  As MockK uses function literals to create stubs, small changes are needed to verify suspend functions. MockK provides functions prefixed with co as equivalents to other functions, such as coVerify. See Coroutines and suspend functions for more details.\nval mockedFile = mockk\u0026lt;File\u0026gt;() coVerify { mockedFile.readAsync() } "}),a.add({id:13,href:'/mockk-guidebook/docs/matching/with/',title:"Assertions with an argument",section:"Argument matching",content:"Run assertions with an argument #  There are some special argument matchers that can only be used when verifying that a mocked function was called. withArg and its variants allow you to capture an argument and run your own assertions on it without the need to set up a capturing slot.\ndata class File( val name: String, val data: ByteArray ) interface FileNetwork { fun download(name: String): File fun upload(file: File) } When using a capturing slot, testing the FileNetwork.download function looks like this:\nval network = mockk\u0026lt;FileNetwork\u0026gt;() val slot = slot\u0026lt;String\u0026gt;() every { network.download(capture(slot)) } returns mockk() network.download(\u0026#34;testfile\u0026#34;) verify { network.download(any()) } assertTrue(\u0026#34;testfile\u0026#34; == slot.captured) withArg simplifies this code so no slot is needed.\nval network = mockk\u0026lt;FileNetwork\u0026gt;() every { network.download(any()) } returns mockk() network.download(\u0026#34;testfile\u0026#34;) verify { network.download(withArg { assertTrue(\u0026#34;testfile\u0026#34; == it) }) } Arrays and data classes #  withArg can be helpful when you use arguments that aren\u0026rsquo;t easily compared, such as a data class containing arrays. The equals() function on an array works differently than on a List. Arrays are only equal if you compare with the exact same instance, while lists are equal if all of their items are equal. Since Kotlin data classes use the equals() function with each property, this array behaviour affects them.\nval expected = File(\u0026#34;hello\u0026#34;, data = \u0026#34;world\u0026#34;.toByteArray()) network.upload(File(\u0026#34;hello\u0026#34;, data = \u0026#34;world\u0026#34;.toByteArray())) // fails because the Files are not equal verify { network.upload(expected) } In your test, you can choose to compare properties individually using withArg.\nval expected = File(\u0026#34;hello\u0026#34;, data = \u0026#34;world\u0026#34;.toByteArray()) network.upload(File(\u0026#34;hello\u0026#34;, data = \u0026#34;world\u0026#34;.toByteArray())) verify { network.upload(withArg { assertTrue(expected.name == it.name) assertTrue(expected.data contentEquals it.data) }) } Nullable arguments #  withNullableArg is also provided by MockK when you wish to use it with a nullable argument.\nCoroutines #  MockK provides variants with withArg and withNullableArg that allow coroutine code to be executed. These variants are coWithArg and coWithNullableArg. If your assertions call a suspend function, these variants should be used.\n"}),a.add({id:14,href:'/mockk-guidebook/docs/mocking/spy/',title:"Spy on existing classes",section:"Mocking",content:"Spy on existing classes #  Rather than mocking an object, you can create spies of real objects. Spies will run the real methods in a class, unlike mocks which don\u0026rsquo;t run anything. Stubbing methods on a spy will run the stub instead, so you can have a mixture of real methods and stubbed methods.\nSpies get their name because you can spy on the code you\u0026rsquo;re testing and see what methods it called. Spies let you verify that a method is called, just like a mock.\n"}),a.add({id:15,href:'/mockk-guidebook/docs/mockito-migrate/arg-that/',title:"`argThat`",section:"Migrating from Mockito",content:"argThat #  The argThat argument matcher in Mockito lets you create advanced argument matchers that run a function on passed arguments, and checks if the function returns true.\nIf you have a complicated class that can\u0026rsquo;t be easily checked using .equals(), a custom matcher can be a useful tool.\n`when`( mockedCar.drive(argThat { engine -\u0026gt; engine.dieselEngine }) ).thenReturn(true) MockK has a similar argument matcher called match. Just like argThat, you can pass a lambda in that returns a boolean.\nevery { mockedCar.drive(match { engine -\u0026gt; engine.dieselEngine }) } returns true MockK also lets you use coroutines with match. Just replace the function with coMatch, then pass a suspend function lambda in. See Coroutines and suspend functions for more details.\n"}),a.add({id:16,href:'/mockk-guidebook/docs/mocking/coroutines/',title:"Coroutines and suspend functions",section:"Mocking",content:"Coroutines and suspend functions #  As MockK uses function literals to create stubs, small changes are needed to stub suspend functions. MockK provides functions prefixed with co as equivalents to other functions, such as coEvery and coAnswers.\nval mockedFile = mockk\u0026lt;File\u0026gt;() coEvery { mockedFile.readAsync() } returns \u0026#34;hello world\u0026#34; coEvery { mockedFile.writeAsync(any()) } coAnswers { call -\u0026gt; doAsyncWork() Unit } The full list of methods with coroutine equivalents is:\n  coEvery  coJustRun  coVerify  coVerifyAll  coVerifyOrder  coVerifySequence  coExcludeRecords  coMatch  coMatchNullable  coWithArg  coWithNullableArg  coAnswers coAndThen coInvoke  "}),a.add({id:17,href:'/mockk-guidebook/docs/matching/custom/',title:"Custom matching functions",section:"Argument matching",content:"Custom matching functions #  When built-in argument matchers aren\u0026rsquo;t sufficient, custom matchers can be written. A custom argument matcher simply needs to take in the argument as a parameter and return true if it matches, and false if it does not. This custom boolean function can then be passed to the special match function.\nevery { mockedCar.drive(match { engine -\u0026gt; engine.type === \u0026#34;Diesel\u0026#34; }) } returns true If the argument is nullable, a variant called matchNullable can be used instead.\nevery { mockedCar.drive(matchNullable { engine -\u0026gt; engine != null \u0026amp;\u0026amp; engine.type === \u0026#34;Diesel\u0026#34; }) } returns true Matcher subclass #  TODO extend Matcher\u0026lt;T\u0026gt;\nInline extension function helper #  TODO MockKMatcherScope extension function\n"}),a.add({id:18,href:'/mockk-guidebook/docs/mockito-migrate/argument-captor/',title:"`ArgumentCaptor`",section:"Migrating from Mockito",content:"ArgumentCaptor #  When you need to run additional assertions on an argument, the ArgumentCaptor is the tool for the job in Mockito. An ArgumentCaptor will keep track of arguments passed to a mocked method, then allow you to retreve the argument later.\nval personArgument = ArgumentCaptor.forClass(Person::class.java) verify(mockPhone).call(personArgument.capture()) assertEquals(\u0026#34;Sarah Jane\u0026#34;, personArgument.value.name) MockK has a similar utility called a CapturingSlot. The functionality is very similar to Mockito, but the usage is different. Rather than calling the method argumentCaptor.capture() to create a argument matcher, you wrap the slot in a capture() function. You access the captured value using the slot.captured property rather than the argumentCaptor.value getter.\nval personSlot = slot\u0026lt;Person\u0026gt;() every { mockPhone.call(capture(personSlot)) } assertEquals(\u0026#34;Sarah Jane\u0026#34;, personSlot.captured.name) As an alternative to CapturingSlot, a MutableList can be used to store captured arguments. Simply pass an instance of a mutable list to capture instead of the slot. This allows you to record all captured values, as CapturingSlot only records the most recent value.\nInline assertions #  It turns out that there is an even simpler way to run assertions on an argument in MockK. The withArg function is an argument matcher that takes a lambda that will be executed when the mocked function is called, with the argument passed to the lambda. This allows you to run assertions without managing argument captors or capturing slots.\nevery { mockPhone.call(withArg { person -\u0026gt; assertEquals(\u0026#34;Sarah Jane\u0026#34;, person.captured.name) }) } When dealing with one-off assertions, withArg will do everything you need with less code.\n"}),a.add({id:19,href:'/mockk-guidebook/docs/matching/capture/',title:"Capture arguments to check later",section:"Argument matching",content:"Capturing arguments to check later #   capture captureNullable captureLambda captureCoroutine invoke/coInvoke (maybe?)  "}),a.add({id:20,href:'/mockk-guidebook/docs/mocking/constructor/',title:"Mock constructors in code you don't own",section:"Mocking",content:"Mock constructors in code you don\u0026rsquo;t own #  Sometimes your classes have dependencies that they construct themselves. While it\u0026rsquo;s best to use a system like dependency injection to avoid this, MockK makes it possible to control constructors and make them return a mocked instance.\nThe mockkConstructor(T::class) function takes in a class reference. Once used, every constructor of that type will start returning a singleton that can be mocked. Rather than building a new instance every time the constructor is called, MockK generates a singleton and always returns the same instance. This will apply to all constructors for a given class, there is no way to distinguish between them.\nThe mocked result can be obtained by using anyConstructed\u0026lt;T\u0026gt;(). Using this function, stubbing and verification can be done just like any other mock.\nUnmocking #  If you\u0026rsquo;d like to revert back to the real constructor, you can use the unmockkConstructor method. This removes any stubbed behaviour you may have added.\n"}),a.add({id:21,href:'/mockk-guidebook/docs/mockito-migrate/void/',title:"`void` methods",section:"Migrating from Mockito",content:"void methods #  Mockito\u0026rsquo;s when method doesn\u0026rsquo;t work with void methods. To create a stub that doesn\u0026rsquo;t return anything, the doNothing method is used.\nval mockedFile = mock(File::class.java) doNothing().`when`(mockedFile).write(any()) MockK doesn\u0026rsquo;t have any restrictions with these methods, as they return Unit in Kotlin. As a result, the standard returns infix function can be used.\nval mockedFile = mockk\u0026lt;File\u0026gt;() every { mockedFile.write(any()) } returns Unit MockK also provides the justRun method as a shorthand for every { x } returns Unit. For more information, see the Returning Unit tip.\nval mockedFile = mockk\u0026lt;File\u0026gt;() justRun { mockedFile.write(any()) } "}),a.add({id:22,href:'/mockk-guidebook/docs/mocking/static/',title:"Mock singleton objects and static methods",section:"Mocking",content:"Mock singleton objects and static methods #  Mocking objects #  When you need a singleton in Kotlin, you can use an object. These specialized classes will only ever have one instance, so you can\u0026rsquo;t mock them in the usual manner. Instead, MockK provides specialized functions to create object mocks.\nobject FeatureFlags { val featureEnabled = true } mockkObject(FeatureFlags) every { FeatureFlags.featureEnabled } returns false // prints false println(FeatureFlags.featureEnabled) Despite the name, object mocks behave more like spies. If a method is not stubbed, then the real method will be called. This differs from regular mocks, where a method will either throw or do nothing if it is not stubbed.\nclass Calculator1 { fun add(a: Int, b: Int) { return a + b } } object Calculator2 { fun add(a: Int, b: Int) { return a + b } } val calculator1 = mockk\u0026lt;Calculator1\u0026gt;() mockkObject(Calculator2) // throws because the method was not stubbed println(calculator1.add(2, 2)) // returns the result from the real method println(Calculator2.add(2, 2)) This approach works with any Kotlin object, which includes companion objects and enum class elements.\nMocking static methods #  Sometimes you may end up working with Java code in your tests, which can have static methods.\npackage com.name.app; class Writer { public static File getFile(String path) { return File(path); } } Just like singleton objects, there will only ever be one version of static methods, so you cannot mock them in the usual manner. Again, MockK provides specialized functions to mock static methods.\nmockkStatic(\u0026#34;com.name.app.Writer\u0026#34;) Rather than passing a reference to the class, you pass the class name as a string. You can also choose to pass in a reference to the class, and MockK will figure out the class name.\nmockkStatic(Writer::class) Like object mocks, static mocks behave like spies. The real method will be called if the method is not stubbed.\nUnmocking #  If you\u0026rsquo;d like to revert back to the real object, you can use the unmockkObject method. This removes any stubbed behaviour you may have added.\nobject Calculator { fun add(a: Int, b: Int) { return a + b } } mockkObject(Calculator) every { Calculator.add(any(), any()) } returns 10 // prints 10 println(Calculator.add(2, 2)) unmockkObject(Calculator) // prints 4 println(Calculator.add(2, 2)) "}),a.add({id:23,href:'/mockk-guidebook/docs/matching/vararg/',title:"Variable arguments",section:"Argument matching",content:"Variable arguments #   anyVararg varargAny varargAll any...Vararg varargAny... varargAll...  "}),a.add({id:24,href:'/mockk-guidebook/docs/matching/compareto/',title:"Comparables",section:"Argument matching",content:"Comparables #   less more range cmpEq  MockK provides a few argument matchers for numbers and comparable objects. These matches all use the compareTo function to compare objects.\nmore #  Checks if the argument is more than the value given to the matcher. Valid arguments will return a negative number when compared to the matcher value.\nassertTrue(value.compareTo(arg) \u0026lt; 0) less #  Checks if the argument is less than the value given to the matcher. Valid arguments will return a positive number when compared to the matcher value.\nassertTrue(value.compareTo(arg) \u0026gt; 0) cmpEq #  Checks if the argument is equal to the value given to the matcher, according to the compareTo function. Valid arguments will return 0 when compared to the matcher value.\nassertTrue(value.compareTo(arg) == 0) range #  TODO\n"}),a.add({id:25,href:'/mockk-guidebook/docs/mocking/extension/',title:"Mock top-level and extension functions",section:"Mocking",content:"Mock top-level and extension functions #  Top-level functions #  Kotlin lets you write functions that don\u0026rsquo;t belong to any class or object, called top-level functions. These calls are translated to static methods in Java, and a special Java class is generated to hold the functions. These top-level functions can be mocked using mockkStatic, but you need to figure out the class name of this generated Java class.\nFinding the class name #  TODO\nExtension functions #  Depending on where an extension function is located, it may correspond to a top-level function or a class member. If placed inside a class, the extension function is attached to that class and can be mocked using the with method.\n// TODO val mock = ...  with (mock) { every { any\u0026lt;Type\u0026gt;().extensionFunction() } returns \u0026#34;result\u0026#34; } If the extension function is inside an object, the code is similar but the object needs to be mocked first.\nWhen the extension function is in the top-level of a file, it can be mocked like other top-level functions using mockkStatic.\n"}),a.add({id:26,href:'/mockk-guidebook/docs/mocking/clear/',title:"Clear state",section:"Mocking",content:"Clear state #  "}),a.add({id:27,href:'/mockk-guidebook/docs/matching/combine/',title:"Combine matchers",section:"Argument matching",content:"Combining matchers #   and or not  "}),a.add({id:28,href:'/mockk-guidebook/docs/mocking/annotation/',title:"Create many mocks quickly with annotations",section:"Mocking",content:"Create many mocks quickly with annotations #  Sometimes you will need to create many mocks in your test class. As each mock needs to be declared as a property in the test class, then initialized in the test setup function, the amount of code needed to build all your mocks can grow very quickly. MockK provides a shorthand using annotations to make this simpler.\nclass RepositoryTest { @MockK private lateinit var foodDatabase: FoodDatabase @MockK private lateinit var recipeDatabase: RecipeDatabase @MockK private lateinit var networkClient: NetworkClient @SpyK private var logger = Logger() @Before fun setup() { MockKAnnotations.init(this) } @Test fun testDatabaseAndNetwork() { // ... use foodDatabase, recipeDatabase, networkClient and debugger  } } Each property with the @MockK annotation is automatically mocked and ready to use in tests. This reduces repetition and makes your tests more readable. The above class is equivalent to:\nclass RepositoryTest { private lateinit var foodDatabase: FoodDatabase private lateinit var recipeDatabase: RecipeDatabase private lateinit var networkClient: NetworkClient private lateinit var logger: Logger @Before fun setup() { foodDatabase = mockk() recipeDatabase = mockk() networkClient = mockk() logger = spyk(Logger()) } @Test fun testDatabaseAndNetwork() { // ... use foodDatabase, recipeDatabase, networkClient and debugger  } } Options #  @MockK annotations take the same options as the mockk function. If you wish to use a relaxed mock, the annotation looks similar to the equivalent mockk call:\n// Annotations class RepositoryTest { @MockK(relaxed = true) private lateinit var foodDatabase: FoodDatabase @MockK(relaxUnitFun = true) private lateinit var recipeDatabase: RecipeDatabase @Before fun setup() { MockKAnnotations.init(this) } } // Long form class RepositoryTest { private lateinit var foodDatabase: FoodDatabase private lateinit var recipeDatabase: RecipeDatabase @Before fun setup() { foodDatabase = mockk(relaxed = true) recipeDatabase = mockk(relaxUnitFun = true) } } In addition to @MockK(relaxed = true), there is an equivalent @RelaxedMockK annotation.\nIf options are shared across every annotated mock, they can be passed to the init call instead.\nclass RepositoryTest { @MockK private lateinit var foodDatabase: FoodDatabase @MockK private lateinit var recipeDatabase: RecipeDatabase @Before fun setup() { MockKAnnotations.init(this, relaxed = true) } } Spies #  TODO\n"}),a.add({id:29,href:'/mockk-guidebook/docs/mocking/answers/',title:"Create more complicated answers for stubs",section:"Mocking",content:"Most stubs will use returns to always return the same value when the corresponding method is called. Sometimes, the method you\u0026rsquo;re trying to mock may be more complicated and require a more advanced stub.\nIf you want to change the result of a mocked method depending on its arguments, run additional code whenever a method is called, or just print out \u0026ldquo;Hello world\u0026rdquo; when a mock is used, answers is the tool you\u0026rsquo;ll want to use.\nanswers takes the place of returns after an every call. When using returns, it should be followed by a value to return. When using answers, it should be followed by a lambda function that is run when the mocked method is called.\nimport io.mockk.every import io.mockk.mockk val navigator = mockk\u0026lt;Navigator\u0026gt;() every { navigator.currentLocation } returns \u0026#34;Home\u0026#34; every { navigator.currentLocation } answers { \u0026#34;Home\u0026#34; } Side effects #  A function has \u0026ldquo;side effects\u0026rdquo; if it does something other than just returning a value, such as logging or mutating some outside state. answers lets you model side effects by putting additional statements inside its lambda function.\nevery { navigator.currentLocation } answers { println(\u0026#34;Hello world!\u0026#34;) \u0026#34;Work\u0026#34; } // prints \u0026#34;Hello world!\u0026#34; val location = navigator.currentLocation // prints \u0026#34;Work\u0026#34; println(location) Answer scope #  Inside of the answers lambda function, you can access information about the mocked method and how it was called. You can then use this to adjust the resulting answer.\nevery { navigator.navigateTo(any()) } answers { val destination = firstArg\u0026lt;String\u0026gt;() throw IllegalStateException(\u0026#34;Can\u0026#39;t reach $destination\u0026#34;) } These values are properties on the MockKAnswerScope class. The scope is passed as a receiver object, allowing variables to be called from the implicit this scope.\nIndividual arguments #  Single arugments can be obtained using firstArg(), secondArg(), thirdArg(), and lastArg(). Other arguments can be obtained with arg(n), where n is the index of the argument. For example, arg(3) would return the fourth argument.\nArguments do not have static type checking. Instead, the type is casted automatically using generic types.\nevery { calculator.add(any\u0026lt;Int\u0026gt;(), any\u0026lt;Int\u0026gt;()) } answers { // tries to cast the second argument to a string  println(secondArg\u0026lt;String\u0026gt;()) 0 } The above code will compile, but when the test is run a ClassCastException will be thrown because you cannot cast an Int to a String.\nAll arguments #  The entire list of arguments can be obtained using args. args has the type List\u0026lt;Any?\u0026gt;, so you will need to manually cast values in the list if you want to work with them.\nevery { calculator.add(any\u0026lt;Int\u0026gt;(), any\u0026lt;Int\u0026gt;()) } answers { val numbers = args as List\u0026lt;Int\u0026gt; numbers.sum() } // prints \u0026#34;4\u0026#34; println(calculator.add(2, 2)) If you only need to know the length of args, aka the number of arguments, you can use nArgs.\nTODO call, invocation, matcher, self, method, captured, lambda, coroutine, nothing, fieldValue, fieldValueAny, value, valueAny.\n"}),a.add({id:30,href:'/mockk-guidebook/docs/getting-started/',title:"Getting Started",section:"Docs",content:"Getting Started #    Why use mocks   I thought lying was bad!   Why MockK?   (TODO) About the MockK framework.   "}),a.add({id:31,href:'/mockk-guidebook/docs/quick/android/',title:"Android",section:"Docs",content:"Android Quickstart #  MockK works great with Android and allows you to mock objects in both your Android unit tests and instrumented tests. MockK can handle mocking Context, static functions, and more to help you test your Android code.\nTo install MockK, all you need to do is add it as a dependency in your module\u0026rsquo;s Gradle file. In most Android Studio projects, this file is located at app/build.gradle. Once you open the file, search for the dependencies block and add a new line.\ndependencies { ... testImplementation \u0026#34;io.mockk:mockk:$mockk_version\u0026#34; } $mockk_version should be replaced with the version of MockK you wish to use. The latest version is listed on the Maven website.\nAfter syncing your project with Gradle files, MockK will be available for use in your unit tests (located in app/src/test). To use MockK in your instrumented tests (located in app/src/androidTest), an additional line is needed in your module\u0026rsquo;s Gradle file.\ndependencies { ... androidTestImplementation \u0026#34;io.mockk:mockk-android:$mockk_version\u0026#34; } Unlike unit tests, instrumented tests are run live on an Android device or emulator.\nTODO add differences between versions\n"}),a.add({id:32,href:'/mockk-guidebook/docs/tips/timeout/',title:"Timeout",section:"Tips",content:"Timeouts #  "}),a.add({id:33,href:'/mockk-guidebook/docs/matching/',title:"Argument matching",section:"Docs",content:"Argument matching #  Argument matchers are placeholders use to specify what values can be used in a function. They can be used with stubs and verification.\n  Check equality   (TODO) Checking if an argument is equal using eq, refEq, isNull, and more.   Allow any argument   (TODO) anything goes here.   Argument of a certain type   (TODO) Don\u0026rsquo;t allow anyone, just arguments that are ofType.   Assertions with an argument   Using withArg to run assertions in verify calls.   Custom matching functions   (TODO) Adding additional matchers with the match function.   Capture arguments to check later   (TODO) capture arguments out of stubs and verify calls into a slot.   Variable arguments   (TODO) Matching variable arguments with anyVararg and more.   Comparables   Matching smaller numbers, bigger numbers, and more.   Combine matchers   (TODO) Logical operators and, or, not for matchers.   "}),a.add({id:34,href:'/mockk-guidebook/docs/method-index/',title:"Method index",section:"Docs",content:"Method index #  Index of MockK methods and corresponding guidebook chapters.\nTop level functions #  mockk\u0026lt;T\u0026gt;(...) #  Chapter: Mocking\nbuilds a regular mock\nspyk\u0026lt;T\u0026gt;() #  Chapter: Spy on existing classes\nbuilds a spy using the default constructor\nspyk(obj) #  Chapter: Spy on existing classes\nbuilds a spy by copying from obj\nslot #  Chapter: Capture arguments to check later\ncreates a capturing slot\nevery #  Chapter: Stub out behaviour\nstarts a stubbing block\ncoEvery #  Chapter: Coroutines and suspend functions\nstarts a stubbing block for coroutines\nverify #  Chapter: Verify that functions were called\nstarts a verification block\ncoVerify #  Chapter: Coroutines and suspend functions\nstarts a verification block for coroutines\nverifyAll #  Chapter: Verify that functions were called\nstarts a verification block that should include all calls\ncoVerifyAll #  Chapter: Coroutines and suspend functions\nstarts a verification block that should include all calls for coroutines\nverifyOrder #  Chapter: Verify that functions were called\nstarts a verification block that checks the order\ncoVerifyOrder #  Chapter: Coroutines and suspend functions\nstarts a verification block that checks the order for coroutines\nverifySequence #  Chapter: Verify that functions were called\nstarts a verification block that checks whether all calls were made in a specified sequence\ncoVerifySequence #  Chapter: Coroutines and suspend functions\nstarts a verification block that checks whether all calls were made in a specified sequence for coroutines\nexcludeRecords #  Chapter: Verify that functions were called\nexclude some calls from being recorded\nconfirmVerified #  Chapter: Verify that functions were called\nconfirms that all recorded calls were verified\nclearMocks #  Chapter: Clear state\nclears specified mocks\nregisterInstanceFactory #  Chapter: TODO\nallows you to redefine the way of instantiation for certain object\nmockkClass #  Chapter: TODO\nbuilds a regular mock by passing the class as parameter\nmockkObject #  Chapter: Mock singleton objects and static methods\nmakes an object an object mock or clears it if was already transformed\nunmockkObject #  Chapter: Mock singleton objects and static methods\nmakes an object mock back to a regular object\nmockkStatic #  Chapter: Mock singleton objects and static methods\nmakes a static mock out of a class or clears it if it was already transformed\nunmockkStatic #  Chapter: Mock singleton objects and static methods\nmakes a static mock back to a regular class\nclearStaticMockk #  Chapter: TODO\nclears a static mock\nmockkConstructor #  Chapter: Mock constructors in code you don\u0026rsquo;t own\nmakes a constructor mock out of a class or clears it if it was already transformed\nunmockkConstructor #  Chapter: Mock constructors in code you don\u0026rsquo;t own\nmakes a constructor mock back to a regular class\nclearConstructorMockk #  Chapter: TODO\nclears the constructor mock\nunmockkAll #  Chapter: TODO\nunmocks object, static and constructor mocks\nclearAllMocks #  Chapter: TODO\nclears regular, object, static and constructor mocks\nMatchers #  By default, simple arguments are matched using eq().\nany() #  Chapter: Allow any argument\nmatches any argument\nallAny() #  Chapter: Allow any argument\nspecial matcher that uses any() instead of eq() for matchers that are provided as simple arguments\nisNull() #  Chapter: TODO\nchecks if the value is null\nisNull(inverse=true) #  Chapter: TODO\nchecks if the value is not null\nofType(type) #  Chapter: Argument of a certain type\nchecks if the value belongs to the type\nmatch { it.startsWith(\u0026quot;string\u0026quot;) } #  Chapter: TODO\nmatches via the passed predicate\ncoMatch { it.startsWith(\u0026quot;string\u0026quot;) } #  Chapter: TODO\nmatches via the passed coroutine predicate\nmatchNullable { it?.startsWith(\u0026quot;string\u0026quot;) } #  Chapter: TODO\nmatches nullable value via the passed predicate\ncoMatchNullable { it?.startsWith(\u0026quot;string\u0026quot;) } #  Chapter: TODO\nmatches nullable value via the passed coroutine predicate\neq(value) #  Chapter: Check equality\nmatches if the value is equal to the provided value via the deepEquals function\neq(value, inverse=true)) #  Chapter: Check equality\nmatches if the value is not equal to the provided value via the deepEquals function\nneq(value) #  Chapter: Check equality\nmatches if the value is not equal to the provided value via deepEquals function\nrefEq(value) #  Chapter: Check equality\nmatches if the value is equal to the provided value via reference comparison\nrefEq(value, inverse=true) #  Chapter: Check equality\nmatches if the value is not equal to the provided value via reference comparison\nnrefEq(value) #  Chapter: Check equality\nmatches if the value is not equal to the provided value via reference comparison\ncmpEq(value) #  Chapter: Check equality\nmatches if the value is equal to the provided value via the compareTo function\nless(value) #  Chapter: Comparables\nmatches if the value is less than the provided value via the compareTo function\nmore(value) #  Chapter: Comparables\nmatches if the value is more than the provided value via the compareTo function\nless(value, andEquals=true) #  Chapter: Comparables\nmatches if the value is less than or equal to the provided value via the compareTo function\nmore(value, andEquals=true) #  Chapter: Comparables\nmatches if the value is more than or equal to the provided value via the compareTo function\nrange(from, to, fromInclusive=true, toInclusive=true) #  Chapter: Comparables\nmatches if the value is in range via the compareTo function\nand(left, right) #  Chapter: Combine matchers\ncombines two matchers via a logical and\nor(left, right) #  Chapter: Combine matchers\ncombines two matchers via a logical or\nnot(matcher) #  Chapter: Combine matchers\nnegates the matcher\ncapture(slot) #  Chapter: Capture arguments to check later\ncaptures a value to a CapturingSlot\ncapture(mutableList) #  Chapter: Capture arguments to check later\ncaptures a value to a list\ncaptureNullable(mutableList) #  Chapter: Capture arguments to check later\ncaptures a value to a list together with null values\ncaptureLambda() #  Chapter: Capture arguments to check later\ncaptures a lambda\ncaptureCoroutine() #  Chapter: Capture arguments to check later\ncaptures a coroutine\ninvoke(...) #  Chapter: TODO\ncalls a matched argument\ncoInvoke(...) #  Chapter: TODO\ncalls a matched argument for a coroutine\nhint(cls) #  Chapter: TODO\nhints the next return type in case it\u0026rsquo;s gotten erased\nanyVararg() #  Chapter: TODO\nmatches any elements in a vararg\nvarargAny(matcher) #  Chapter: TODO\nmatches if any element is matching the matcher\nvarargAll(matcher) #  Chapter: TODO\nmatches if all elements are matching the matcher\nany...Vararg() #  Chapter: TODO\nmatches any elements in vararg (specific to primitive type)\nvarargAny...(matcher) #  Chapter: TODO\nmatches if any element is matching the matcher (specific to the primitive type)\nvarargAll...(matcher) #  Chapter: TODO\nmatches if all elements are matching the matcher (specific to the primitive type)\nA few special matchers available in verification mode only:\nwithArg { code } #  Chapter: Assertions with an argument\nmatches any value and allows to execute some code\nwithNullableArg { code } #  Chapter: Assertions with an argument\nmatches any nullable value and allows to execute some code\ncoWithArg { code } #  Chapter: TODO\nmatches any value and allows to execute some coroutine code\ncoWithNullableArg { code } #  Chapter: TODO\nmatches any nullable value and allows to execute some coroutine code\nValidators #  verify { mock.call() } #  Chapter: TODO\nDo unordered verification that a call was performed\nverify(inverse=true) { mock.call() } #  Chapter: TODO\nDo unordered verification that a call was not performed\nverify(atLeast=n) { mock.call() } #  Chapter: TODO\nDo unordered verification that a call was performed at least n times\nverify(atMost=n) { mock.call() } #  Chapter: TODO\nDo unordered verification that a call was performed at most n times\nverify(exactly=n) { mock.call() } #  Chapter: TODO\nDo unordered verification that a call was performed exactly n times\nverifyAll { mock.call1(); mock.call2() } #  Chapter: TODO\nDo unordered verification that only the specified calls were executed for the mentioned mocks\nverifyOrder { mock.call1(); mock.call2() } #  Chapter: TODO\nDo verification that the sequence of calls went one after another\nverifySequence { mock.call1(); mock.call2() } #  Chapter: TODO\nDo verification that only the specified sequence of calls were executed for the mentioned mocks\nverify { mock wasNot Called } #  Chapter: TODO\nDo verification that a mock was not called\nverify { listOf(mock1, mock2) wasNot Called } #  Chapter: TODO\nDo verification that a list of mocks were not called\nAnswers #  An Answer can be followed up by one or more additional answers.\nreturns value #  Chapter: TODO\nspecify that the matched call returns a specified value\nreturnsMany list #  Chapter: TODO\nspecify that the matched call returns a value from the list, with subsequent calls returning the next element\nthrows ex #  Chapter: TODO\nspecify that the matched call throws an exception\nanswers { code } #  Chapter: TODO\nspecify that the matched call answers with a code block scoped with answer scope\ncoAnswers { code } #  Chapter: TODO\nspecify that the matched call answers with a coroutine code block with answer scope\nanswers answerObj #  Chapter: TODO\nspecify that the matched call answers with an Answer object\nanswers { nothing } #  Chapter: TODO\nspecify that the matched call answers null\njust Runs #  Chapter: TODO\nspecify that the matched call is returning Unit (returns null)\npropertyType Class #  Chapter: TODO\nspecify the type of backing field accessor\nnullablePropertyType Class #  Chapter: TODO\nspecify the type of backing field accessor as a nullable type\nAdditional answer(s) #  A next answer is returned on each consequent call and the last value is persisted. So this is similar to the returnsMany semantics.\nandThen value #  Chapter: TODO\nspecify that the matched call returns one specified value\nandThenMany list #  Chapter: TODO\nspecify that the matched call returns value from the list, returning each time next element\nandThenThrows ex #  Chapter: TODO\nspecify that the matched call throws an exception\nandThen { code } #  Chapter: TODO\nspecify that the matched call answers with a code block scoped with answer scope\ncoAndThen { code } #  Chapter: TODO\nspecify that the matched call answers with a coroutine code block with answer scope\nandThenAnswer answerObj #  Chapter: TODO\nspecify that the matched call answers with an Answer object\nandThen { nothing } #  Chapter: TODO\nspecify that the matched call answers null\nAnswer scope #  call #  Chapter: TODO\na call object that consists of an invocation and a matcher\ninvocation #  Chapter: TODO\ncontains information regarding the actual function invoked\nmatcher #  Chapter: TODO\ncontains information regarding the matcher used to match the invocation\nself #  Chapter: TODO\nreference to the object invocation made\nmethod #  Chapter: TODO\nreference to the function invocation made\nargs #  Chapter: TODO\nreference to the arguments of invocation\nnArgs #  Chapter: TODO\nnumber of invocation argument\narg(n) #  Chapter: TODO\nn-th argument\nfirstArg() #  Chapter: TODO\nfirst argument\nsecondArg() #  Chapter: TODO\nsecond argument\nthirdArg() #  Chapter: TODO\nthird argument\nlastArg() #  Chapter: TODO\nlast argument\ncaptured() #  Chapter: TODO\nthe last element in the list for convenience when capturing to a list\nlambda\u0026lt;...\u0026gt;().invoke() #  Chapter: TODO\ncall the captured lambda\ncoroutine\u0026lt;...\u0026gt;().coInvoke() #  Chapter: TODO\ncall the captured coroutine\nnothing #  Chapter: TODO\nnull value for returning nothing as an answer\nfieldValue #  Chapter: TODO\naccessor to the property backing field\nfieldValueAny #  Chapter: TODO\naccessor to the property backing field with Any? type\nvalue #  Chapter: TODO\nvalue being set casted to same type as the property backing field\nvalueAny #  Chapter: TODO\nvalue being set with Any? type\nVararg scope #  position #  Chapter: TODO\nthe position of an argument in vararg array\nnArgs #  Chapter: TODO\noverall count of arguments in vararg array\n"}),a.add({id:35,href:'/mockk-guidebook/docs/mockito-migrate/',title:"Migrating from Mockito",section:"Docs",content:"Migrating from Mockito #  Learn how to use MockK by seeing equivalents to functions in Mockito.\n  Create a mock   The similarities and differences in creating mocks between Mockito and MockK.   `when` and `do*`   when(x).thenReturn(y), doReturn, and more.   `eq`   Mockito\u0026rsquo;s eq, refEq, and same argument matchers.   `any*`   The \u0026ldquo;any\u0026rdquo; family of matchers: any, anyBoolean, anyByte, anyChar, anyDouble, anyFloat, anyInt, anyLong, anyObject, anyShort, and anyString.   `verify`   verify that a method was called.   `argThat`   Porting custom matchers with argThat   `ArgumentCaptor`   Capturing arguments to check them later.   `void` methods   MockK makes it easier to mock methods that return void.   "}),a.add({id:36,href:'/mockk-guidebook/docs/mocking/',title:"Mocking",section:"Docs",content:"Mocking #  Mocking start with one call, the mockk function. This function takes in a class and returns a fake version of it, where all functions are present but will throw when called.\nimport io.mockk.mockk val mockedFile = mockk\u0026lt;File\u0026gt;()   Stub out behaviour   Using every and returns to define behaviour.   Verify that functions were called   Using verify to check that a function was used.   Automatically stub by relaxing   How to change the default mockk result with relaxed.   Spy on existing classes   Using spyk to mix mocks and real classes.   Coroutines and suspend functions   Using coEvery, coVerify, and more to mock coroutines.   Mock constructors in code you don\u0026#39;t own   Advanced mocking with mockkConstructor.   Mock singleton objects and static methods   Advanced static mocking with mockkStatic and mockkObject.   Mock top-level and extension functions   Mocking top-level functions with mockkStatic.   Clear state   (TODO) Clearing the state of a mock.   Create many mocks quickly with annotations   The @MockK and @SpyK shortcuts.   Chain mocks into hierarchies   (TODO) Building a mock with less code using lambdas.   Create more complicated answers for stubs   Using answers when returns just isn\u0026rsquo;t enough.   "}),a.add({id:37,href:'/mockk-guidebook/docs/tips/unit/',title:"Return `Unit`",section:"Tips",content:"Return Unit #  When stubbing a function that returns nothing, MockK provides a few shortcuts.\nval logger = mockk\u0026lt;Logger\u0026gt;() every { logger.log(any()) } returns Unit every { logger.log(any()) } answers { Unit } every { logger.log(any()) } just Runs justRun { logger.log(any()) } just Runs is the nicest to use, since its shorter than returns and answers and additionally works with coEvery.\ncoEvery { logger.log(any()) } just Runs "}),a.add({id:38,href:'/mockk-guidebook/docs/tips/',title:"Tips",section:"Docs",content:"Tips #  In this section we present a number of tips that we have collected over the course of using MockK in the real world.\n  Chains     Exclude     Timeout   Timeouts #   Return `Unit`   Return Unit # When stubbing a function that returns nothing, MockK provides a few shortcuts. val logger = mockk\u0026lt;Logger\u0026gt;() every { logger.log(any()) } returns Unit every { logger.log(any()) } answers { Unit } every { logger.log(any()) } just Runs justRun { logger.log(any()) } just Runs is the nicest to use, since its shorter than returns and answers and additionally works with coEvery. coEvery { logger.log(any()) } just Runs   "})})()